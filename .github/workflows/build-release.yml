name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  build-linux-macos:
    runs-on: ubuntu-latest
    environment: production
    env:
      EAI_BUILD_SECRET: ${{ secrets.EAI_BUILD_SECRET }}
    strategy:
      matrix:
        node-version: [18.x]

    steps:
      - name: Verify build authorization
        run: |
          if [ -z "$EAI_BUILD_SECRET" ]; then
            echo "‚ùå EAI_BUILD_SECRET not found. Build not authorized."
            exit 1
          fi
          echo "‚úÖ Build authorized"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build TypeScript
        run: npm run build

      - name: Build Linux and macOS CLI executables
        run: |
          npm run pkg:linux
          npm run pkg:macos

      - name: Install UI dependencies and build UI
        run: |
          cd ui
          npm ci
          npm run build:prod

      - name: Build UI Linux and macOS executables
        run: |
          cd ui
          npm run dist:linux
          npm run dist:mac

      - name: Install osslsigncode for cross-platform Windows signing
        run: sudo apt-get update && sudo apt-get install -y osslsigncode

      - name: Setup GPG for Linux signing
        if: env.GPG_PRIVATE_KEY != ''
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --batch --import
          echo "GPG key imported successfully"

      - name: Sign Linux executable
        env:
          GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: npm run sign:linux

      - name: Upload Linux CLI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-cli-executables
          path: |
            bin/index-linux
            bin/index-linux.sig
            bin/index-linux.sha256
          retention-days: 30
        # Note: GitHub Actions artifacts are automatically zipped for
        # intermediate storage. The final release will extract and upload
        # these as individual executable files

      - name: Upload Linux UI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-ui-executables
          path: ui/release/*.AppImage
          retention-days: 30

      - name: Upload macOS CLI artifacts (unsigned)
        uses: actions/upload-artifact@v4
        with:
          name: macos-cli-executables-unsigned
          path: bin/index-macos
          retention-days: 30
        # Note: GitHub Actions artifacts are automatically zipped for
        # intermediate storage
        # The final release will extract and upload these as individual
        # executable files

      - name: Upload macOS UI artifacts (unsigned)
        uses: actions/upload-artifact@v4
        with:
          name: macos-ui-executables-unsigned
          path: ui/release/*.dmg
          retention-days: 30

  build-windows:
    runs-on: windows-latest
    environment: production
    env:
      EAI_BUILD_SECRET: ${{ secrets.EAI_BUILD_SECRET }}
    strategy:
      matrix:
        node-version: [18.x]

    steps:
      - name: Verify build authorization
        shell: powershell
        run: |
          if ([string]::IsNullOrEmpty($env:EAI_BUILD_SECRET)) {
            Write-Host "‚ùå EAI_BUILD_SECRET not found. Build not authorized." -ForegroundColor Red
            exit 1
          }
          Write-Host "‚úÖ Build authorized" -ForegroundColor Green

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Build Windows CLI executable
        run: npm run pkg:windows

      - name: Install UI dependencies and build UI
        run: |
          cd ui
          npm ci
          npm run build:prod

      - name: Build UI Windows executable
        run: |
          cd ui
          npm run dist:win

      - name: Setup certificate for Windows signing
        if: env.WINDOWS_CERT_FILE != ''
        env:
          WINDOWS_CERT_FILE: ${{ secrets.WINDOWS_CERT_FILE }}
        shell: powershell
        run: |
          $certBytes = [System.Convert]::FromBase64String($env:WINDOWS_CERT_FILE)
          [System.IO.File]::WriteAllBytes("$env:TEMP\certificate.p12", $certBytes)
          echo "WINDOWS_CERT_FILE_PATH=$env:TEMP\certificate.p12" >> $env:GITHUB_ENV

      - name: Sign Windows CLI executable
        env:
          WINDOWS_CERT_FILE: ${{ env.WINDOWS_CERT_FILE_PATH }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
        run: npm run sign:windows
        continue-on-error: true

      - name: Upload Windows CLI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-cli-executables
          path: |
            bin/index-win.exe
            bin/index-win.exe.sha256
          retention-days: 30
        # Note: GitHub Actions artifacts are automatically zipped for
        # intermediate storage
        # The final release will extract and upload these as individual
        # executable files

      - name: Upload unsigned Windows executable (fallback)
        if: ${{ !hashFiles('bin/index-win.exe.sha256') }}
        uses: actions/upload-artifact@v4
        with:
          name: windows-executables-unsigned
          path: bin/index-win.exe
          retention-days: 30
        # Note: Fallback for unsigned executables - final release will still be individual files

      - name: Upload Windows UI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-ui-executables
          path: ui/release/*.exe
          retention-days: 30

  sign-macos:
    runs-on: macos-latest
    environment: production
    env:
      EAI_BUILD_SECRET: ${{ secrets.EAI_BUILD_SECRET }}
    needs: build-linux-macos

    steps:
      - name: Verify build authorization
        run: |
          if [ -z "$EAI_BUILD_SECRET" ]; then
            echo "‚ùå EAI_BUILD_SECRET not found. Build not authorized."
            exit 1
          fi
          echo "‚úÖ Build authorized"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download unsigned macOS CLI executable
        uses: actions/download-artifact@v4
        with:
          name: macos-cli-executables-unsigned
          path: bin/

      - name: Download unsigned macOS UI executable
        uses: actions/download-artifact@v4
        with:
          name: macos-ui-executables-unsigned
          path: ui/release/

      - name: Setup Apple certificates
        if: env.APPLE_CERTIFICATE_P12 != ''
        env:
          APPLE_CERTIFICATE_P12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create certificate file
          echo "$APPLE_CERTIFICATE_P12" | base64 -d > certificate.p12

          # Create temporary keychain
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain

          # Import certificate
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain

          # Clean up certificate file
          rm certificate.p12

      - name: Sign macOS CLI executable
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_NOTARIZATION_USERNAME: ${{ secrets.APPLE_NOTARIZATION_USERNAME }}
          APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Install Node.js for signing script
          export PATH="/usr/local/bin:$PATH"
          node scripts/sign-macos.js

      - name: Upload signed macOS CLI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-cli-executables-signed
          path: bin/index-macos
          retention-days: 30
        # Note: GitHub Actions artifacts are automatically zipped for
        # intermediate storage
        # The final release will extract and upload these as individual
        # executable files

      - name: Upload signed macOS UI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-ui-executables-signed
          path: ui/release/*.dmg
          retention-days: 30

  release:
    needs: [build-linux-macos, build-windows, sign-macos]
    runs-on: ubuntu-latest
    environment: production
    env:
      EAI_BUILD_SECRET: ${{ secrets.EAI_BUILD_SECRET }}
    if: always() && startsWith(github.ref, 'refs/tags/v') && (needs.build-linux-macos.result == 'success' && needs.build-windows.result == 'success')

    steps:
      - name: Verify build authorization
        run: |
          if [ -z "$EAI_BUILD_SECRET" ]; then
            echo "‚ùå EAI_BUILD_SECRET not found. Release not authorized."
            exit 1
          fi
          echo "‚úÖ Release authorized"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Linux CLI artifacts
        uses: actions/download-artifact@v4
        with:
          name: linux-cli-executables
          path: bin/

      - name: Download Linux UI artifacts
        uses: actions/download-artifact@v4
        with:
          name: linux-ui-executables
          path: ui-bin/

      - name: Download Windows CLI artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-cli-executables
          path: bin/
        continue-on-error: true

      - name: Download unsigned Windows artifacts (fallback)
        if: ${{ hashFiles('bin/index-win.exe') == '' }}
        uses: actions/download-artifact@v4
        with:
          name: windows-executables-unsigned
          path: bin/

      - name: Download Windows UI artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-ui-executables
          path: ui-bin/

      - name: Download signed macOS CLI artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-cli-executables-signed
          path: bin/
        continue-on-error: true

      - name: Download unsigned macOS CLI artifacts (fallback)
        if: ${{ hashFiles('bin/index-macos') == '' }}
        uses: actions/download-artifact@v4
        with:
          name: macos-cli-executables-unsigned
          path: bin/

      - name: Download signed macOS UI artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-ui-executables-signed
          path: ui-bin/
        continue-on-error: true

      - name: Download unsigned macOS UI artifacts (fallback)
        if: ${{ hashFiles('ui-bin/*.dmg') == '' }}
        uses: actions/download-artifact@v4
        with:
          name: macos-ui-executables-unsigned
          path: ui-bin/

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded artifacts from build jobs:"
          echo "CLI executables:"
          ls -la bin/
          echo "UI executables:"
          ls -la ui-bin/
          echo "These will be renamed with version and uploaded as individual executable files to the release."

      - name: Rename executables with version
        run: |
          VERSION=${{ github.ref_name }}
          
          echo "üè∑Ô∏è  Renaming executables with version ${VERSION}"
          
          # Rename CLI executables
          mv bin/index-macos bin/eai-security-check-cli-macos-${VERSION}
          mv bin/index-linux bin/eai-security-check-cli-linux-${VERSION}
          mv bin/index-win.exe bin/eai-security-check-cli-windows-${VERSION}.exe
          
          # Rename UI executables (find and rename dynamically)
          find ui-bin -name "*.AppImage" -exec mv {} bin/eai-security-check-ui-linux-${VERSION}.AppImage \;
          find ui-bin -name "*.dmg" -exec mv {} bin/eai-security-check-ui-macos-${VERSION}.dmg \;
          find ui-bin -name "*.exe" -exec mv {} bin/eai-security-check-ui-windows-${VERSION}.exe \;
          
          # Rename signature and checksum files
          if [ -f bin/index-linux.sig ]; then
            mv bin/index-linux.sig bin/eai-security-check-cli-linux-${VERSION}.sig
          fi
          if [ -f bin/index-linux.sha256 ]; then
            mv bin/index-linux.sha256 bin/eai-security-check-cli-linux-${VERSION}.sha256
          fi
          if [ -f bin/index-win.exe.sha256 ]; then
            mv bin/index-win.exe.sha256 bin/eai-security-check-cli-windows-${VERSION}.exe.sha256
          fi

          echo "‚úÖ Final release files ready:"
          ls -la bin/

      - name: Check signing status
        run: |
          VERSION=${{ github.ref_name }}
          echo "üîç Checking signing status for release notes..."

          # Check macOS signing
          MACOS_SIGNED="‚ö†Ô∏è  Unsigned"
          if [ -f "bin/eai-security-check-macos-${VERSION}" ]; then
            if command -v codesign >/dev/null 2>&1; then
              if codesign -dv "bin/eai-security-check-macos-${VERSION}" 2>&1 | grep -q 'Authority='; then
                MACOS_SIGNED="‚úÖ **Code Signed**"
              fi
            fi
          fi
          echo "MACOS_SIGNED=${MACOS_SIGNED}" >> $GITHUB_ENV

          # Check Linux signing
          LINUX_SIGNED="‚ö†Ô∏è  Unsigned"
          if [ -f "bin/eai-security-check-linux-${VERSION}.sig" ]; then
            LINUX_SIGNED="‚úÖ **GPG Signed**"
          fi
          echo "LINUX_SIGNED=${LINUX_SIGNED}" >> $GITHUB_ENV

          # Check Windows checksum
          WINDOWS_CHECKSUM="‚ö†Ô∏è  No checksum"
          if [ -f "bin/eai-security-check-windows-${VERSION}.exe.sha256" ]; then
            WINDOWS_CHECKSUM="‚úÖ **Checksum Available**"
          fi
          echo "WINDOWS_CHECKSUM=${WINDOWS_CHECKSUM}" >> $GITHUB_ENV

          echo "üìä Signing status: macOS=${MACOS_SIGNED}, Linux=${LINUX_SIGNED}, Windows=${WINDOWS_CHECKSUM}"

      - name: Create GitHub Release with Individual Executables
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ github.ref_name }}

          echo "üöÄ Creating GitHub release with individual executable files (not zipped)"

          # Build file list for release - these will be uploaded as individual files
          RELEASE_FILES=()
          
          # CLI executables
          RELEASE_FILES+=("./bin/eai-security-check-cli-macos-${VERSION}")
          RELEASE_FILES+=("./bin/eai-security-check-cli-linux-${VERSION}")
          RELEASE_FILES+=("./bin/eai-security-check-cli-windows-${VERSION}.exe")
          
          # UI executables  
          if [ -f "./bin/eai-security-check-ui-macos-${VERSION}.dmg" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-ui-macos-${VERSION}.dmg")
          fi
          if [ -f "./bin/eai-security-check-ui-linux-${VERSION}.AppImage" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-ui-linux-${VERSION}.AppImage")
          fi
          if [ -f "./bin/eai-security-check-ui-windows-${VERSION}.exe" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-ui-windows-${VERSION}.exe")
          fi
          
          # Add signature files if they exist
          if [ -f "./bin/eai-security-check-cli-linux-${VERSION}.sig" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-cli-linux-${VERSION}.sig")
            echo "üìù Adding Linux GPG signature file"
          fi
          if [ -f "./bin/eai-security-check-cli-linux-${VERSION}.sha256" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-cli-linux-${VERSION}.sha256")
            echo "üîç Adding Linux checksum file"
          fi
          if [ -f "./bin/eai-security-check-cli-windows-${VERSION}.exe.sha256" ]; then
            RELEASE_FILES+=("./bin/eai-security-check-cli-windows-${VERSION}.exe.sha256")
            echo "üîç Adding Windows checksum file"
          fi
          fi

          echo "üìã Files to be uploaded as individual downloads:"
          for file in "${RELEASE_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "  ‚úÖ $file ($(stat -c %s "$file" 2>/dev/null || stat -f %z "$file" 2>/dev/null || echo "unknown size") bytes)"
            else
              echo "  ‚ùå $file (missing)"
            fi
          done

          gh release create ${{ github.ref_name }} \
            --title "Release ${{ github.ref_name }}" \
            --notes "## EAI Security Check Release

          ### üì¶ Available Versions
          This release includes both **Command Line Interface (CLI)** and **Graphical User Interface (UI)** versions:

          #### üñ•Ô∏è Command Line Interface (CLI)
          - **macOS**: \`eai-security-check-cli-macos-${VERSION}\` $([ -f ./bin/eai-security-check-cli-macos-${VERSION} ] && codesign -dv ./bin/eai-security-check-cli-macos-${VERSION} 2>&1 | grep -q 'Authority=' && echo '‚úÖ **Code Signed**' || echo '‚ö†Ô∏è  Unsigned')
          - **Linux**: \`eai-security-check-cli-linux-${VERSION}\` $([ -f ./bin/eai-security-check-cli-linux-${VERSION}.sig ] && echo '‚úÖ **GPG Signed**' || echo '‚ö†Ô∏è  Unsigned')
          - **Windows**: \`eai-security-check-cli-windows-${VERSION}.exe\` $([ -f ./bin/eai-security-check-cli-windows-${VERSION}.exe.sha256 ] && echo '‚úÖ **Checksum Available**' || echo '‚ö†Ô∏è  No checksum')

          #### üñ±Ô∏è Graphical User Interface (UI)
          - **macOS**: \`eai-security-check-ui-macos-${VERSION}.dmg\` - Desktop application with modern Angular interface
          - **Linux**: \`eai-security-check-ui-linux-${VERSION}.AppImage\` - Portable desktop application
          - **Windows**: \`eai-security-check-ui-windows-${VERSION}.exe\` - Desktop installer with modern interface

          ### üÜö CLI vs UI - Choose Your Experience

          **Use CLI if you:**
          - Prefer command-line tools
          - Want to integrate with scripts/automation
          - Need minimal resource usage
          - Are running on servers/headless systems

          **Use UI if you:**
          - Prefer graphical interfaces
          - Want visual dashboard and report viewing
          - Need report format conversion (JSON, HTML, Markdown, CSV)
          - Want point-and-click configuration management

          ### üîê Security & Verification
          - All executables are built from source with reproducible builds
          - GPG signatures provided for Linux executables when available (verify with \`.sig\` files)
          - SHA256 checksums provided for integrity verification when available
          - Code signing certificates used where available

          ### üöÄ Quick Start

          **CLI Quick Start:**
          \`\`\`bash
          # macOS
          chmod +x eai-security-check-cli-macos-${VERSION}
          ./eai-security-check-cli-macos-${VERSION} check eai

          # Linux
          chmod +x eai-security-check-cli-linux-${VERSION}
          ./eai-security-check-cli-linux-${VERSION} check eai

          # Windows (PowerShell)
          ./eai-security-check-cli-windows-${VERSION}.exe check eai
          \`\`\`

          **UI Quick Start:**
          \`\`\`bash
          # macOS
          open eai-security-check-ui-macos-${VERSION}.dmg

          # Linux
          chmod +x eai-security-check-ui-linux-${VERSION}.AppImage
          ./eai-security-check-ui-linux-${VERSION}.AppImage

          # Windows
          ./eai-security-check-ui-windows-${VERSION}.exe
          \`\`\`

          ### üéØ New UI Features
          - **Dashboard**: Overview of system status and recent security checks
          - **Report Viewer**: View, convert, and copy reports in multiple formats (JSON, HTML, Markdown, CSV, Plain Text)
          - **Configuration Editor**: Visual interface for managing security profiles
          - **Daemon Manager**: Setup automated security monitoring with email notifications
          - **Interactive Mode**: Step-by-step guided security management
          - **Cross-Platform**: Runs natively on Windows, macOS, and Linux

          ### üîç Signature Verification

          **Linux GPG Verification:**
          \`\`\`bash
          # Import signing key (first time only)
          curl -fsSL https://github.com/eaiti/eai_security_check/releases/download/${VERSION}/signing-key.pub | gpg --import

          # Verify signature
          gpg --verify eai-security-check-cli-linux-${VERSION}.sig eai-security-check-cli-linux-${VERSION}
          \`\`\`

          **Checksum Verification:**
          \`\`\`bash
          # Linux/macOS
          sha256sum -c eai-security-check-linux-${VERSION}.sha256

          # Windows (PowerShell)
          Get-FileHash eai-security-check-cli-windows-${VERSION}.exe -Algorithm SHA256
          \`\`\`

          ### üìã Features
          - **Cross-platform**: Now supports macOS, Linux, and Windows
          - **Dual interface**: Both CLI and GUI options available
          - **Security-focused**: FileVault, disk encryption, firewall, and access control checks
          - **Multiple profiles**: default, strict, relaxed, developer, eai configurations
          - **Detailed reporting**: Actionable recommendations with educational content
          - **Report conversion**: Convert reports between JSON, HTML, Markdown, CSV, and Plain Text
          - **Daemon mode**: Scheduled automated security audits with email notifications
          - **Signed executables**: Reduced security warnings on supported platforms
          - **Modern UI**: Angular-based desktop application with responsive design" \
            \${RELEASE_FILES[@]}
